# DevSecOps CI/CD Security Pipeline Project

This project demonstrates a complete DevSecOps pipeline using GitHub Actions. It includes a vulnerable Python Flask application, containerizes it with Docker, and runs a series of automated security scans before deploying it.

The primary goal is to "shift left" security by integrating automated checks early in the development lifecycle. The pipeline is configured to "break the build" if critical security issues are detected.

## Project Structure

```
ci-cd-secured-pipeline/
  ├── app/                     # Vulnerable Python Flask web app
  │    ├── app.py
  │    └── requirements.txt
  ├── tests/                   # Basic unit tests
  │    └── test_app.py
  ├── Dockerfile               # Containerizes the app with security best practices
  ├── .github/workflows/       # GitHub Actions CI/CD pipeline
  │    └── pipeline.yml
  ├── results/                 # Stores scan reports (generated by pipeline)
  └── README.md                # This file
```

## Security Tools Integrated

| Tool | Type | Purpose |
| :--- | :--- | :--- |
| **Bandit** | SAST | Scans Python source code for common security vulnerabilities like insecure deserialization and command injection. |
| **Gitleaks** | Secret Scanning | Scans the Git repository history for hardcoded secrets like API keys and passwords. |
| **pip-audit**| SCA | Scans `requirements.txt` to find dependencies with known vulnerabilities from the Python Packaging Advisory Database. |
| **Trivy** | Container Scanning | Scans the final Docker image for vulnerabilities in OS packages and application dependencies. |

## How to Run

### On GitHub Actions

1.  **Fork this repository.**
2.  **Push a commit.** The pipeline defined in `.github/workflows/pipeline.yml` will automatically trigger.
3.  **Observe the pipeline run.** Go to the "Actions" tab in your forked repository. You will see the pipeline fail at the security scan stages because of the intentional vulnerabilities in the code.
4.  **Analyze the reports.** The reports from each tool (`gitleaks-report.json`, `bandit-report.json`, etc.) are uploaded as artifacts. You can download and inspect them from the completed workflow run page.

### Running Scans Locally

You can run each security tool locally to get faster feedback before committing your code.

**Prerequisites:**
*   Python 3.9+ installed
*   Docker installed

**1. Bandit (SAST)**
```bash
# Install Bandit
pip install bandit

# Run scan
bandit -r app/ -f screen -s B101,B602,B403
# Expected: Finds hardcoded password, subprocess with shell=True, pickle usage.
```

**2. Gitleaks (Secret Scanning)**
```bash
# Install Gitleaks (macOS example)
brew install gitleaks

# Run scan
gitleaks detect --source . -v
# Expected: Finds the fake API_KEY in app/app.py.
```

**3. pip-audit (SCA)**
```bash
# Install pip-audit
pip install pip-audit

# Run scan
pip-audit -r app/requirements.txt
# Expected: Finds vulnerabilities in Flask==1.1.2.
```

**4. Trivy (Container Scanning)**
```bash
# Build the Docker image first
docker build -t my-vulnerable-app .

# Run Trivy scan
docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
  aquasec/trivy:latest image my-vulnerable-app
# Expected: Finds vulnerabilities in the base image's OS packages and in the installed Python packages.
```

## Learning Outcomes

*   **Practical Implementation:** You have a working example of a DevSecOps pipeline with multiple security gates.
*   **Understanding Tooling:** You learn the purpose and basic usage of key open-source security tools (SAST, SCA, Secret Scanning, Container Scanning).
*   **Shift-Left in Action:** By running these checks on every commit, you see how security becomes a proactive part of development, not an afterthought.
*   **Breaking the Build:** The pipeline demonstrates how to enforce security policies by failing the build when critical issues are found, preventing vulnerable code from reaching production.
